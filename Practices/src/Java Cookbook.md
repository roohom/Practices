# JAVA Cookbook

### IDEA 常用快捷键
> Alt+shift+上下方向键 移动当前代码行（选中的代码块）  
> ctrl+N 当前项目中的文件过多时，方便快速查找定位文件  
> ctrl+D 复制光标所在行（选中的代码块）  
> ctrl+Y 删除光标所在行（选中的代码块）  
> Ctrl+ALT+L 针对当前的代码进行代码格式化 
> ALT+Enter 在IDEA中当书写程序时，遇到红色提示时可以使用该快捷键来解决该提示问题 


### 常量
- 字符常量
    - 字符和字符串
        - 字符使用单引号，如 'A'
        - 字符串使用双引号，如"ABC"
- 字符串常量
- 布尔常量
    - True or False
- 空常量
    - null                  
    - 不能通过输出语句直接打印
    
### 变量
在程序运行过程中可以改变的量  
变量的定义格式: 数据类型 变量名=变量值 如 int a=10；    

### 数据类型
Java是一门**强类型**语言：在定义变量时就指定了变量的具体类型，在程序运行过程中无法对变量的类型进行修改
弱类型:Scala语言
- 基本数据类型
    - 整数
        - byte     一个字节，取值范围:-128~127
        - short   两个字节， 15次方
        - 默认 int   四个字节，31次方
        - long    八个字节
            - 为了区分，在值末尾加上L
    - 小数
        - float 四个字节，单精度浮点数 默认六到八位
        - 默认 double 八个字节，双精度浮点数 
    - 字符
        - char 两个字节， 英文单引号包含的单个字符
    - 布尔Boolean 一个字节
        - True
        - False
    ![avatar](./字符类型.png)
- 引用数据类型
    - 类
    - 接口
    - 数组[]

- 标识符
给程序中变量、类、方法、数组等起的名字
要求(命名规则):
    - 标识符只能由:大小字母、数字、下划线、$组成
    - 必须是以：英文字母或下划线或$开头（不能是数字开头）
    - 不能是Java中的关键字
- 命名规范:    
    - 类名、接口的命名规范:大驼峰命名法
    - 变量、方法的命名规范:小驼峰命名法
    - 包的命名全部都以小写字母为主，通常名称是使用域名倒着写    
    
    
### 类型转换
- 自动类型转换(隐式类型转换)
    - 原则:小类型转换为大类型
        byte -> short int long float double 
        short -> int  long float double
        int -> long float double
        float -> double 
        char -> int -> long
- 强制类型转换(显示类型转换)    
    - 原则: 在程序中，把大类型转换为小类型，不能自动转换，需要手动强制进行转换
    格式: 小类型名 变量=(小类型名) 大类型的运算结果
    
### 运算符
- 在Java中任何数据类型和字符串相加，"+"的作用都变成了拼接，其结果都是拼接字符串
    - 例:S.o.p("5+5"+5+5); 输出是5+5=55
    - 而S.o.p("5+5"+(5+5));结果才是5+5=10     
- 在Java中一元运算的优先级高于二元运算    
    - 一元运算
        - 自增
            - 只能用于变量
            - b = a++ 先赋值,再参与运算
            - b = ++a 先参与运算，再赋值
        - 自减
            - 道理同自增
    - a += 1之类的计算结果等同于  a = a+1
    - 但是内部机制并不是如此:
        short s=1;
        s += 10;
        其实等价于
        short s=1;
        s = (short) (s+10);
    - 二元运算
        - 加、减、乘、除、取余           

- 逻辑运算符
只能针对Boolean进行运算 
    - **短路与**&&
        - 作用：等同于逻辑与(&)
        - 特殊之处:
            - 当&&之前的运算结果为false时，其后面的运算不会再执行(在与操作中已经得到了一个否，则结果必为否)。
            - 执行速度更快
    - **短路或**||   
        - 作用:等同于逻辑或(|)
        - 特殊之处:
            - 当||之前的结果为false时，其后面的表达式便不会再执行
            - 速度更快
    
- 三元运算符
格式:  
数据类型 变量名 = (关系表达式) ? 表达式1:表达式2  
> 变量接收的是表达式1的运算结果或者是表达式2的运算结果
> 如果关系表达式为true，则执行表达式1
> 如果关系表达式为false，则执行表达式2


- 键盘录入
试用步骤:
    - 1.导入Scanner包 import java.util.Scanner;
    - 2.创建Scanner对象,Scanner sc = new Scanner(System.in);
    - 3.获取键盘录入的数据:
        如:String str = sc.next(); 
        如:int num = sc.nextInt();
    
### 分支结构
- switch语句
    - 当判断的条件不是进行区间比较时，仅只是进行两个数据之间相等的比较时
    - switch之后的括号里可以接收变量、常量和表达式
    需要确保其类型必须是byte、short、int、char、String或枚举
    - default可以书写在任何位置，但除了末尾的位置都必须写break
    - case穿透现象
    - **假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2**
        ~~~java
        witch(表达式){
            case 值1: 	
                语句体1;	//假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2;
            case 值2:
                语句体2;
                break;
            case 值3:
                语句体3;
                break;
                  ...    //根据需求, 可以写多组case.
            default:	
                语句体n;
                break;
      }
        ~~~
    - 案例 SwitchPenetrate.java
### 循环
- 三种循环
    - for循环
        - 流程
            - 1.执行循环初始值
            - 2.判断循环条件是否满足
            - 3.执行for循环体重的代码
            - 4.修改循环条件中的值
            - 重复2、3、4
            - 直到不满足循环条件
        - 特点:
            - 先判断，再执行循环体
        - 句式语法
            - ~~~java
              for(循环初始值;循环条件;循环条件中值的修改)
              {
                  code block;
              }
              ~~~
    - while循环
    - do...while循环
- 循环三要素
    - 循环初始值
    - 循环条件
    - 循环条件中值的修改(修改循环条件)  
- 循环差异
    - 在for循环执行完之后，无法使用for循环里的初始化条件，比如循环执行过程中自动改变的变量
    - 而在while循环执行完之后，他的循环条件却还可以使用         
    
    
### 随机数
在java中提供的一个获取[0.0~1.0)之间的随机数字的包Random
~~~java
1.导入包（省去）
2.创建对象
3.使用获取随机数的功能
~~~    
- 使用
    - 格式
    Math.random()   
    ~~~java
    int num = (int)(Math.random()*100+1); //生成一个1-100之间的随机整数
    ~~~ 
- 在java中如果使用Math.random()生成随机数  
如果是要生成[10,100]的随机数， (int)(Math.random()*91+10)   
提取其中的(**公式**) :将Math.random()用MR代替。
如果是要求[a,b]范围，则是MR*((b-a)+1)+a  
如果是[a,b)范围，则是MR*(b-a)+a  

### 数组
定义的方式:  
举例:
- 动态初始化
    - int array[] = new int[5]
    - int[] array = new int[5]    
- 静态初始化
    - int[] array = new int[]{1,2,3,4,5}   
    - int array[] = {1,2,3,4,5}
- 数组的遍历可以使用for循环，同时java也提供了一个方法来直接打印数组 -> Arrays.toString(arr)
打印的结果形式是[元素,元素,...]
### Java程序的内存划分
- 栈
    - 作用:存储局部变量，程序要运行的代码，局部变量就是定义在方法中的变量，栈中存放的就是方法
    - 特点:先进后出(FILO)
- 堆
    - 作用:存储使用new关键字，创建出来的内容(即:对象)
    - 特点:存储在堆中的内容，是由Java中的垃圾回收器(GC),统一管理回收
- 方法区:
    - 存放.class文件
- 本地方法区
    - 常量存放在常量池中，而常量池就在方法区中
- 寄存器            

### 方法
- 什么是方法?
    - 在程序中把一段代码进行抽取并封装，封装为一个具有独立功能的代码块，这块代码起个名称之后就成为“方法”
    - main()就是一个方法
    - 方法(method)也叫函数(function),在具体实现上是一样的
    - public static void main(String[] args),public static是修饰符,void表示没有返回值,main就是方法名,String[] args是参数
    
- 方法可以传递数据    
- 方法可以返回结果
- 好处:提高了代码的**复用率**

  
- 方法的重载
    - 同样的方法，不同的参数列表(参数个数、参数类型以及参数的顺序)    
    - 参数的传递有基本数据类型和引用数据类型
    - 当传递的参数是基本数据类型，形参的改变对实参没有任何影响
        ~~~java
          public static void main(String[] args) {
                  int number = 100;
                  System.out.println("调用change方法前：" + number);
                  change(number);	 //实参.
                  System.out.println("调用change方法后：" + number);
              }     
              public static void change(int number) {	//形参.
                  number = 200;
              }    
        ~~~
      <font color="red">上面代码在调用change和调用之后number的数值都是200</font>
    - 方法中传递的参数类型是引用数据类型时，传递的是地址值(内存中开辟的空间的地址值)，当在方法中对传递的引用类型的参数
    进行相关操作时，会直接影响实参  
        ~~~java
          public static void main(String[] args) {
                  int[] arr = {10, 20, 30};
                  System.out.println("调用change方法前：" + arr[1]);
                  change(arr);
                  System.out.println("调用change方法后：" + arr[1]);
              }
          
              public static void change(int[] arr) {
                  arr[1] = 200;
              }
        ~~~
      调用之前打印的是20，调用之后打印的是200